<?php
/**
 * 鸡蛋掉落 困难
 *
 * 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
你的目标是确切地知道 F 的值是多少。
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
动态规划
可以换一个思路来想：“求k个鸡蛋在m步内可以测出多少层”。我们令dp[k][m]表示k个鸡蛋在m步内可以测出的最多的层数，那么当我们在第X层扔鸡蛋的时候，就有两种情况：

鸡蛋碎了，我们少了一颗鸡蛋，也用掉了一步，此时测出N - X + dp[k-1][m-1]层，X和它上面的N-X层已经通过这次扔鸡蛋确定大于F；
鸡蛋没碎，鸡蛋的数量没有变，但是用掉了一步，剩余X + dp[k][m-1]，X层及其以下已经通过这次扔鸡蛋确定不会大于F；
也就是说，我们每一次扔鸡蛋，不仅仅确定了下一次扔鸡蛋的楼层的方向，也确定了另一半楼层与F的大小关系，所以在下面的关键代码中，使用的不再是max，而是加法（这里是重点）。评论里有人问到为什么是相加，其实这里有一个惯性思维的误区，上面的诸多解法中，往往求max的思路是“两种方式中较大的那一个结果”，其实这里的相加，不是鸡蛋碎了和没碎两种情况的相加，而是“本次扔之后可能测出来的层数 + 本次扔之前已经测出来的层数”
 */
class Solution{
	public function superEggDrop($K,$N){
		$step = 0;
		$dp = [];
        for (; $dp[$K] < $N; $step++) {
            for ($i = $K; $i > 0; $i--)
                $dp[$i] += (1+ $dp[$i-1]);
        }
        return $step;

	}
}
$s = new Solution();
echo "<pre>";
print_r($s->superEggDrop(3,14));